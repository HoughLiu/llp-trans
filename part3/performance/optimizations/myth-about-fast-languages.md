16.1.1 Myth About Fast Languages

有一个比较常见的误解：语言能够决定程序的执行速度。优秀并且有用的性能测试经常是被高度特化的。这些测试以非常特殊的 case 来对性能进行测量，而非更为通用的测定方式。因此当别人给出一些性能的语句时，最好能将测试的场景细节和结果一并给出。通过详细地描述我们能够创建类似的评测系统并运行差不多的测试，从而得到可比较的结论。

在一些 case 下，用 C 写的程序可能会被类似行为的 Java 程序胜过。而这种情况和语言本身没什么关系。

举个例子，malloc 这种典型的实现有一个特点：没有办法预测该实现的执行时间。一般来说，时间取决于当前的堆状态：有多少 block 存在，堆的碎片化程度怎么样等等。很多情况下在堆上分配内存都会比在栈上要得多一些。然而在典型的 JVM 实现中，内存分配非常快速。这是因为 Java 有非常简单的堆结构。简化来说，就只是一段内存区域和内部的一个指针，

it is just a memory region and a pointer inside it, which delimits an occupied area from the free one. Allocating memory means moving this pointer further into the free part, which is fast.

However, it has its cost: to get rid of the memory chunks we do not need anymore, garbage collection is performed, which might stop the program for an unknown period of time.

We imagine a situation in which garbage collection never happens, for example, a program allocates memory, performs computations, and exits, destroying all address space without invoking the garbage collector. In this case it is possible that a Java program performs faster just because of the careful allocation overhead imposed bymalloc. However, if we use a custom memory allocator, fitting our specific needs for a particular task, we might do the same trick in C, changing the outcome drastically.

Additionally, as Java is usually interpreted and compiled in runtime, virtual machine has access to runtime optimizations that are based on how exactly the program is executed. For example, methods that are often executed one after another can be placed near each other in memory, so that they are placed in a cache together. In order to do that, certain information about program execution trace should be collected, which is only possible in runtime.

What really distinguishes C from other languages is a very transparent costs model. Whatever you  
 are writing, it is easy to imagine which assembly instructions will be emitted. Contrary to that, languages destined primarily to work inside a runtime \(Java, C\#\), or providing multiple additional abstractions, such as C++ with its virtual inheritance mechanism, are harder to predict. The only two real abstractions C provides are structures/unions and functions.

Being translated naively in machine instructions, a C program works very slowly. It is no match to a code generated by a good optimizing compiler. Usually, a programmer does not have more knowledge about low-level architecture details than the compiler, which is much needed to perform low-level optimizations, so he will not be able to compete with the compiler. Otherwise, sometimes, for a particular platform and compiler, one might change a program, usually reducing its readability and maintainability, but in a way that will speed up the code. Again, performance tests are mandatory for everyone.

