实模式是最古老的模式。这种模式没有虚拟内存的概念；操作系统直接在物理内存上进行寻址，通用寄存器只有 16 位长。

因此，没有什么 rax，eax，只有 ax，al 和 ah。

这些寄存器可以保存从 0 到 65535 大小的值，所以我们使用这样的寄存器也就只有 65535 字节的寻址能力。这样的内存区域被称为段\(segment\)。不要把这里的段和 ELF\(Executable and Linkable Format\)文件中的段\(section\)搞混了。

下面是在实模式中使用到的寄存器：

* ip，flags；
* ax，bx，cx，dx，sp，bp，si，di；
* 段寄存器：cs，ds，ss，es，\(还有 gs 和 fs\)

因为 16 位的寄存器不能简单地定位大于 64 KB 的内存，工程师们想出了一个办法来解决这个问题。使用一种特殊的段寄存器，像下面这样：

* 物理内存地址由 20 位组成\(5 个十六进制数\)

* 每个逻辑地址都由两部分组成。一部分从段寄存器中取，用来标识段的起始位置。另一部分记录的是地址在段内的偏移量。硬件用这两个寄存器来计算物理地址：

  物理地址 = 段基址  \* 16 + 偏移量

  你可能经常看到以段地址加偏移量来表示的地址，例如：4a40:0002， ds:0001，7bd3:ah。

我们已经提到过，程序员希望将代码和数据\(以及栈\)分离开，比如他们希望能为代码中的内容使用不同的代码段\(section\)。段\(Segment\)寄存器 cs 就是为这个目的打造的。cs 中存储了代码段的起始地址，ds 则对应数据，ss 对应栈段。其它的段寄存器用来存储其它的数据段。

严格意义上说，段寄存器并不是存储的段的起始地址，而只是地址的一部分\(四个主要的十六进制数\)。给这个数值乘以 16 然后再加上一个 0 才能拿到真正的段起始地址。

每一条汇编指令都隐式地假定了会使用一个段寄存器来组成地址的一部分。在文档中会对每条指令默认使用了哪些寄存器进行说明。不过常识已经可以帮助我们进行判断了。例如 mov 指令是操作数据的，所以地址一定是和数据段\(ds\)有关系。



