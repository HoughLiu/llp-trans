4.4 Features

虚拟内存是物理内存的一层抽象。如果没有这种抽象那么我们就得直接和物理内存地址打交道。

虚拟内存的出现使我们可以假装认为每一个程序都是唯一的内存用户，因为程序在内存空间上确实与其它程序实现了隔离。

单个进程的地址空间被划分为相等长度\(一般是 4KB\)的页。这些页会被动态地管理起来。其中某些页可能会被备份到外置存储\(在 swap 文件中\)，在需要的时候再从外存储中读取回来。

虚拟内存通过对内存页的内存操作\(读，写\)赋予特殊的含义，从而提供了很有用的一些特性。

* 我们可以通过内存输入/输出的映射方式来和外置存储直接通信了\(e.g.把数据写入到一个和外部设备关联的地址，或从这个地址读取数据\)。
* 在操作系统和文件系统的帮助下，实现了内存页和外部存储的文件相关联。
* 某些内存页可以被多个进程所共享。
* 大部分内存地址是**禁用**的---就是说它们的地址未定义，且尝试访问会引发错误。这种操作会导致程序异常终止。
  Linux 和其它 Unix-based 系统使用**信号**来通知应用程序异常的场景。所有类型的信号都可以通过声明一个 handler 来处理。
  访问禁用地址会被操作系统拦截，并且会发送一个 SIGSEGV 信号给应用程序。Segmentation fault 这种错误相信大家见的也不少，它就是这种情况下会引发的错误。
* 一些内存页和外存里的文件关联\(可执行文件自身，库等\)，但还有一些没有关联外存文件。这些叫做**匿名页**，匿名页和栈、**堆**所代表的内存区域所关联---其中堆是动态分配的内存区域。之所以被称为匿名页是由于这些页没有在文件系统里关联的内容。相反的，正在运行的可执行的数据文件和外部设备\(这些东西也被抽象为文件\)都在文件系统里有名字。

一段连续的内存区域如果满足下述条件，就被称为 region：

* 起始地址是页大小的整数倍\(e.g. 4KB\)。
* 所有页都有相同的权限。

如果空闲物理内存被用完了，一些页就会被换出到外部存储并且存储在一个 swap 文件中，或者也可能只是扔掉了\(防止出现脏页的情况\)。在 Windows 中，这个文件叫做 PageFile.sys，在  \*nix 系统中会在磁盘中为交换文件专门设置一个分区。决定换出页的策略在**替换策略**中有所描述，例如：

* 最近最少使用
* 最近使用
* 随机\(选一个页\)

有 caching 的任何类型的系统都有替换策略。

---

■Question 47 阅读替换策略的相关资料。还有其它的策略存在么？

---

每一个进程都有一个内存页的工作组。其包含了该进程当前在内存里的页的记录。

---

■Allocation 当一个进程需要更多内存时会发生什么？它自己没有办法获得更多的页，所以会向操作系统请求更多页。系统会为其提供更多的可用内存地址。

高级语言\(C++，Java，C\# 等\)的动态内存分配最终都会变成向系统请求内存页，在内存用完之前使用这些分配好的页，内存用完之后再申请更多的页。

---



