对于一个单任务的操作系统来说，任意时刻只会有一个程序在执行，这种情况下从固定的地址开始，把程序的数据直接放在物理内存是明智的做法。其它的组件\(例如设备驱动、库\)也可以在内存以固定的顺序来存放。

然而在多任务友好的系统里就没法这么做了，我们更需要一种框架来支持并行\(或者伪并行\)执行多个程序。这种情况下操作系统需要一种内存管理机制来应对下列挑战：

* 被执行的程序有任意的大小\(程序的大小甚至会超过内存的总大小\)。因此需要提供部分加载功能，以使系统可以只加载即将使用到的程序部分。

* 内存中同时存在多个程序。

  程序还能和响应缓慢的外部设备交互。这些缓慢的交互过程可能会持续成千上万个 cpu 时钟周期，我们希望能够把宝贵的 CPU 资源借给其它程序使用。而程序间的快速切换只有当程序都已经在内存中时才可能实现；否则的话还要花费大量的时间从外部存储中把要切换的程序读取进来。.

* 程序可以存储到内存的任意位置。  
  如果我们实现这个目标的话，就可以在任意的空闲内存位置加载程序了。即使程序内部使用的是绝对地址也没关系。

  使用绝对地址的情况可能类似这样，mov rax \[0x1010ffba\]，包括起始地址的所有地址都是固定的。并且这些准确的地址值已经被写入到了机器码中。

* 把程序员从内存管理的任务中尽量解放出来。

  当编程时，我们并不希望思考我们的目标机器迥异的内存芯片如何工作，机器上还有多少可用的内存等等。程序员应该把精力聚集在程序逻辑上。

* Effective usage of shared data and code.

* 有效地使用共享数据和代码

* 无论什么时候，多个程序想要访问内存中的同一份数据或者代码\(库\)文件，对这些内容进行复制都是一种浪费，要尽量避免。

虚拟内存的使用将应对这些挑战。



